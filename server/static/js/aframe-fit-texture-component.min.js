!function(t){function n(r){if(e[r])return e[r].exports;var i=e[r]={exports:{},id:r,loaded:!1};return t[r].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var e={};n.m=t,n.c=e,n.p="",n(0)}([function(t,n,e){"use strict";function r(t){if(Array.isArray(t)){for(var n=0,e=Array(t.length);n<t.length;n++)e[n]=t[n];return e}return Array.from(t)}function i(t){for(var n=0,e=t.length-1;/\s/g.test(t[n]);)n++;for(;/\s/g.test(t[e]);)e--;return t.substring(n,e+1)}var o=function(){function t(t,n){var e=[],r=!0,i=!1,o=void 0;try{for(var a,s=t[Symbol.iterator]();!(r=(a=s.next()).done)&&(e.push(a.value),!n||e.length!==n);r=!0);}catch(t){i=!0,o=t}finally{try{!r&&s.return&&s.return()}finally{if(i)throw o}}return e}return function(n,e){if(Array.isArray(n))return n;if(Symbol.iterator in Object(n))return t(n,e);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}();if("undefined"==typeof AFRAME)throw new Error("Component attempted to register before AFRAME was available.");var a,s=e(1);AFRAME.registerComponent("lsystem",{schema:{axiom:{type:"string",default:"F"},productions:{default:"F:FF",parse:function(t){return t.split(" ").map(function(t){return t.split(":")})}},segmentMixins:{type:"string",parse:function(t){for(var n=0,e=t.indexOf(":",n),r=new Map;-1!==e;){n=e+1;var o=t.indexOf(":",n),a=t.slice(e-1,e),s=t.slice(e+1,-1===o?t.length:o-1).replace(/[\[\]]/g,"").split(",").map(i);r.set(a,s),e=o}return r}},iterations:{type:"int",default:1},angle:{default:90},translateAxis:{type:"string",default:"y",parse:function(t){if("x"===(t=t.toLowerCase()))return new THREE.Vector3(1,0,0);if("y"===t)return new THREE.Vector3(0,1,0);if("z"===t)return new THREE.Vector3(0,0,1);throw new Error('translateAxis has to be a string: "x", "y" or "z"')}},scaleFactor:{default:1},dynamicSegmentLength:{default:!0},mergeGeometries:{type:"boolean",default:!0},functionsInProductions:{type:"boolean",default:!0}},init:function(){void 0===a&&(a=e(3)),this.sceneEl=document.querySelector("a-scene");var t=this;this.initWorker(),this.X=new THREE.Vector3(1,0,0),this.Y=new THREE.Vector3(0,1,0),this.Z=new THREE.Vector3(0,0,1),this.xPosRotation=new THREE.Quaternion,this.xNegRotation=new THREE.Quaternion,this.yPosRotation=new THREE.Quaternion,this.yNegRotation=new THREE.Quaternion,this.zPosRotation=new THREE.Quaternion,this.zNegRotation=new THREE.Quaternion,this.yReverseRotation=new THREE.Quaternion,this.xPosRotation=new THREE.Quaternion,this.xNegRotation=new THREE.Quaternion,this.yPosRotation=new THREE.Quaternion,this.yNegRotation=new THREE.Quaternion,this.zPosRotation=new THREE.Quaternion,this.zNegRotation=new THREE.Quaternion,this.yReverseRotation=new THREE.Quaternion,this.segmentLengthFactor=1;var n=t.data.scaleFactor;this.LSystem=new a({axiom:"F",productions:{F:"F"},finals:{"+":function(){t.transformationSegment.quaternion.multiply(t.yPosRotation)},"-":function(){t.transformationSegment.quaternion.multiply(t.yNegRotation)},"&":function(){t.transformationSegment.quaternion.multiply(t.zNegRotation)},"^":function(){t.transformationSegment.quaternion.multiply(t.zPosRotation)},"\\":function(){t.transformationSegment.quaternion.multiply(t.xNegRotation)},"<":function(){t.transformationSegment.quaternion.multiply(t.xNegRotation)},"/":function(){t.transformationSegment.quaternion.multiply(t.xPosRotation)},">":function(){t.transformationSegment.quaternion.multiply(t.xPosRotation)},"|":function(){t.transformationSegment.quaternion.multiply(t.yReverseRotation)},"!":function(){t.segmentLengthFactor*=n,t.transformationSegment.scale.set(t.transformationSegment.scale.x*=n,t.transformationSegment.scale.y*=n,t.transformationSegment.scale.z*=n),t.colorIndex++},"'":function(){t.segmentLengthFactor*=1/n,t.transformationSegment.scale.set(t.transformationSegment.scale.x*=1/n,t.transformationSegment.scale.y*=1/n,t.transformationSegment.scale.z*=1/n),t.colorIndex=Math.max(0,t.colorIndex-1)},"[":function(){t.stack.push(t.transformationSegment.clone())},"]":function(){t.transformationSegment=t.stack.pop()}}})},update:function(t){if(!1===this.data.mergeGeometries&&void 0!==this.segmentElementGroupsMap){var n=!0,e=!1,r=void 0;try{for(var i,o=this.segmentElementGroupsMap.values()[Symbol.iterator]();!(n=(i=o.next()).done);n=!0){var a=i.value;a.removeObject3D("mesh"),a.innerHTML=""}}catch(t){e=!0,r=t}finally{try{!n&&o.return&&o.return()}finally{if(e)throw r}}}if(0===Object.keys(t).length)this.updateLSystem(),this.updateSegmentMixins(),this.updateTurtleGraphics();else{var s=!1;(t.axiom&&t.axiom!==this.data.axiom||t.iterations&&t.iterations!==this.data.iterations||t.productions&&JSON.stringify(t.productions)!==JSON.stringify(this.data.productions))&&(this.updateLSystem(),s=!0),void 0!==t.segmentMixins&&JSON.stringify(Array.from(t.segmentMixins.entries()))!==JSON.stringify(Array.from(this.data.segmentMixins.entries()))&&(this.updateSegmentMixins(),s=!0),(s||t.angle&&t.angle!==this.data.angle)&&this.updateTurtleGraphics()}},calculateSegmentLength:function(t,n){if(this.segmentLengthMap.has(t))return this.segmentLengthMap.get(t);n.computeBoundingBox();var e=void 0;return this.data.translateAxis.equals(this.X)?e=Math.abs(n.boundingBox.min.x-n.boundingBox.max.x):this.data.translateAxis.equals(this.Y)?e=Math.abs(n.boundingBox.min.y-n.boundingBox.max.y):this.data.translateAxis.equals(this.Z)&&(e=Math.abs(n.boundingBox.min.z-n.boundingBox.max.z)),this.segmentLengthMap.set(t,e),e},initWorker:function(){this.worker=new s},pushSegment:function(t){var n=this,e=this,r=e.transformationSegment.quaternion.clone(),i=e.transformationSegment.position.clone(),o=e.transformationSegment.scale.clone(),a=Math.min(this.colorIndex,this.data.segmentMixins.get(t).length-1),s=this.mixinMap.get(t+a);if(!1===this.data.mergeGeometries)!function(){var l=document.createElement("a-entity");l.setAttribute("mixin",s),l.addEventListener("loaded",function(t){var n=e.segmentLengthMap.get(s);l.object3D.children[0].translateOnAxis(e.data.translateAxis,n*e.segmentLengthFactor/2),l.object3D.quaternion.copy(r),l.object3D.position.copy(i),l.object3D.scale.copy(o)}),n.segmentElementGroupsMap.get(t+a).appendChild(l)}();else{var l=this.segmentObjects3DMap.get(t+a).clone();l.quaternion.copy(r),l.position.copy(i),l.scale.copy(o),l.matrixAutoUpdate=!1,l.updateMatrix(),this.mergeGroups.get(t+a).geometry.merge(l.geometry,l.matrix)}var c=this.segmentLengthMap.get(s);this.transformationSegment.translateOnAxis(this.data.translateAxis,c*this.segmentLengthFactor)},updateLSystem:function(){var t=this,n=this,e={axiom:this.data.axiom,productions:this.data.productions,iterations:this.data.iterations};return Date.now()-this.worker.startTime>1e3&&(this.worker.terminate(),this.initWorker()),this.worker.startTime=Date.now(),this.workerPromise=new Promise(function(e,r){t.worker.onmessage=function(t){console.log(t),n.LSystem.setAxiom(t.data.result),e()}}),this.worker.postMessage(e),this.workerPromise},updateSegmentMixins:function(){var t=this;console.log("update mixins");var n=this;this.el.innerHTML="",this.segmentElementGroupsMap=new Map,this.mixinMap=new Map;var e=!0,r=!1,i=void 0;try{for(var a,s=this.data.segmentMixins[Symbol.iterator]();!(e=(a=s.next()).done);e=!0)for(var l=o(a.value,2),c=l[0],u=l[1],m=0;m<u.length;m++)this.mixinMap.set(c+m,u[m])}catch(t){r=!0,i=t}finally{try{!e&&s.return&&s.return()}finally{if(r)throw i}}if(this.segmentObjects3DMap=new Map,this.segmentLengthMap=new Map,this.mergeGroups=new Map,this.mixinPromises=[],this.data.segmentMixins&&0!==this.data.segmentMixins.length){var d=!0,h=!1,f=void 0;try{for(var p,y=this.data.segmentMixins[Symbol.iterator]();!(d=(p=y.next()).done);d=!0)!function(){var e=p.value,r=o(e,2),i=r[0],a=r[1];t.LSystem.setFinal(i,function(){n.pushSegment.bind(n,i)()});for(var s=0;s<a.length;s++)!function(e){var r=e,o=a[r];n.mixinPromises.push(new Promise(function(e,a){var s=document.createElement("a-entity");if(s.setAttribute("id",o+"-group-"+r+Math.floor(1e4*Math.random())),s.setAttribute("geometry","buffer",!1),s.setAttribute("mixin",o),s.addEventListener("loaded",function(t){var a=s.getObject3D("mesh").clone();s.getObject3D("mesh").geometry.dispose(),a.geometry=a.geometry.clone();var l=n.calculateSegmentLength(o,a.geometry);if(!0===n.data.mergeGeometries){var c=n.data.translateAxis.clone().multiplyScalar(l*n.segmentLengthFactor/2);a.geometry.applyMatrix((new THREE.Matrix4).makeTranslation(c.x,c.y,c.z)),n.segmentObjects3DMap.set(i+r,a)}s.removeObject3D("mesh"),e()}),t.segmentElementGroupsMap.has(i+r)){var l=t.segmentElementGroupsMap.get(i+r);t.segmentElementGroupsMap.delete(i+r),t.el.removeChild(l)}t.segmentElementGroupsMap.set(i+r,s),t.el.appendChild(s)}))}(s)}()}catch(t){h=!0,f=t}finally{try{!d&&y.return&&y.return()}finally{if(h)throw f}}}},updateTurtleGraphics:function(){var t=this;Promise.all([].concat(r(this.mixinPromises),[this.workerPromise])).then(function(){if(t.transformationSegment=new THREE.Object3D,!0===t.data.mergeGeometries){var n=!0,e=!1,r=void 0;try{for(var i,a=t.segmentObjects3DMap[Symbol.iterator]();!(n=(i=a.next()).done);n=!0){var s=o(i.value,2),l=s[0],c=s[1];t.mergeGroups.set(l,new THREE.Mesh(new THREE.Geometry,c.material))}}catch(t){e=!0,r=t}finally{try{!n&&a.return&&a.return()}finally{if(e)throw r}}}t.stack=[],t.colorIndex=0,t.lineWidth=5e-4,t.lineLength=.125;var u=t.data.angle;if(t.xPosRotation.setFromAxisAngle(t.X,Math.PI/180*u),t.xNegRotation.setFromAxisAngle(t.X,Math.PI/180*-u),t.yPosRotation.setFromAxisAngle(t.Y,Math.PI/180*u),t.yNegRotation.setFromAxisAngle(t.Y,Math.PI/180*-u),t.yReverseRotation.setFromAxisAngle(t.Y,Math.PI/180*180),t.zPosRotation.setFromAxisAngle(t.Z,Math.PI/180*u),t.zNegRotation.setFromAxisAngle(t.Z,Math.PI/180*-u),t.LSystem.final(),!0===t.data.mergeGeometries){var m=!0,d=!1,h=void 0;try{for(var f,p=t.segmentElementGroupsMap[Symbol.iterator]();!(m=(f=p.next()).done);m=!0){var y=f.value,b=o(y,2),g=b[0],x=b[1];0===t.mergeGroups.get(g).geometry.vertices.length?t.el.removeChild(x):(x.setObject3D("mesh",t.mergeGroups.get(g)),x.setAttribute("mixin",t.mixinMap.get(g)))}}catch(t){d=!0,h=t}finally{try{!m&&p.return&&p.return()}finally{if(d)throw h}}}})},remove:function(){},tick:function(t){},pause:function(){},play:function(){}}),e(4)},function(t,n,e){t.exports=function(){return e(2)("/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\t// Require instead of importScripts because we use webpack\n\t// with worker-loader for compiling source: https://github.com/webpack/worker-loader\n\tvar LSystem = __webpack_require__(1);\n\tvar lsystem = new LSystem({});\n\tvar timeout = {};\n\n\tonmessage = function onmessage(e) {\n\t  // wait a few ms to start thread, to be able to cancel old tasks\n\t  clearTimeout(timeout);\n\t  timeout = setTimeout(function () {\n\n\t    lsystem.setAxiom(e.data.axiom);\n\n\t    lsystem.clearProductions();\n\t    var _iteratorNormalCompletion = true;\n\t    var _didIteratorError = false;\n\t    var _iteratorError = undefined;\n\n\t    try {\n\t      for (var _iterator = e.data.productions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t        var p = _step.value;\n\n\t        lsystem.setProduction(p[0], p[1]);\n\t      }\n\t    } catch (err) {\n\t      _didIteratorError = true;\n\t      _iteratorError = err;\n\t    } finally {\n\t      try {\n\t        if (!_iteratorNormalCompletion && _iterator.return) {\n\t          _iterator.return();\n\t        }\n\t      } finally {\n\t        if (_didIteratorError) {\n\t          throw _iteratorError;\n\t        }\n\t      }\n\t    }\n\n\t    lsystem.iterate(e.data.iterations);\n\n\t    postMessage({\n\t      result: lsystem.getString(),\n\t      initial: e.data\n\t    });\n\t  }, 20);\n\t};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\t// Get a list of productions that have identical initiators,\n\t// Output a single stochastic production. Probability per production\n\t// is defined by amount of input productions (4 => 25% each, 2 => 50% etc.)\n\n\tfunction transformClassicStochasticProductions(productions) {\n\n\t  return function transformedProduction() {\n\t    var resultList = productions; // the parser for productions shall create this list\n\t    var count = resultList.length;\n\n\t    var r = Math.random();\n\t    for (var i = 0; i < count; i++) {\n\t      var range = (i + 1) / count;\n\t      if (r <= range) return resultList[i];\n\t    }\n\n\t    console.error('Should have returned a result of the list, something is wrong here with the random numbers?.');\n\t  };\n\t};\n\n\t// TODO: Scaffold classic parametric and context sensitive stuff out of main file\n\t// And simply require it here, eg:\n\t// this.testClassicParametricSyntax = require(classicSyntax.testParametric)??\n\tfunction testClassicParametricSyntax(axiom) {\n\t  return (/\\(.+\\)/.test(axiom)\n\t  );\n\t};\n\n\t// transforms things like 'A(1,2,5)B(2.5)' to\n\t// [ {symbol: 'A', params: [1,2,5]}, {symbol: 'B', params:[25]} ]\n\t// strips spaces\n\tfunction transformClassicParametricAxiom(axiom) {\n\n\t  // Replace whitespaces, then split between square brackets.\n\t  var splitAxiom = axiom.replace(/\\s+/g, '').split(/[\\(\\)]/);\n\t  // console.log('parts:', splitAxiom)\n\t  var newAxiom = [];\n\t  // Construct new axiom by getting the params and symbol.\n\t  for (var i = 0; i < splitAxiom.length - 1; i += 2) {\n\t    var params = splitAxiom[i + 1].split(',').map(Number);\n\t    newAxiom.push({ symbol: splitAxiom[i], params: params });\n\t  }\n\t  // console.log('parsed axiom:', newAxiom)\n\t};\n\n\t// transform a classic syntax production into valid JS production\n\t// TODO: Only work on first part pf production P[0]\n\t// -> this.transformClassicCSCondition\n\tfunction transformClassicCSProduction(p, ignoredSymbols) {\n\t  var _this = this;\n\n\t  // before continuing, check if classic syntax actually there\n\t  // example: p = ['A<B>C', 'Z']\n\n\t  // left should be ['A', 'B']\n\t  var left = p[0].match(/(.+)<(.)/);\n\n\t  // right should be ['B', 'C']\n\t  var right = p[0].match(/(.)>(.+)/);\n\n\t  // Not a CS-Production (no '<' or '>'),\n\t  //return original production.\n\t  if (left === null && right === null) {\n\t    return p;\n\t  }\n\n\t  // indexSymbol should be 'B' in A<B>C\n\t  // get it either from left side or right side if left is nonexistent\n\t  var indexSymbol = left !== null ? left[2] : right[1];\n\n\t  // double check: make sure that the right and left match got the same indexSymbol (B)\n\t  if (left !== null && right !== null && left[2] !== right[1]) {\n\t    throw new Error('index symbol differs in context sensitive production from left to right check.', left[2], '!==', right[1]);\n\t  }\n\n\t  // finally build the new (valid JS) production\n\t  // (that is being executed instead of the classic syntax,\n\t  //  which can't be interpreted by the JS engine)\n\t  var transformedFunction = function transformedFunction(_ref) {\n\t    var _index = _ref.index;\n\t    var _part = _ref.part;\n\t    var _axiom = _ref.currentAxiom;\n\t    var _params = _ref.params;\n\n\n\t    var leftMatch = { result: true };\n\t    var rightMatch = { result: true };\n\n\t    // this can possibly be optimized (see: https://developers.google.com/speed/articles/optimizing-javascript#avoiding-pitfalls-with-closures)\n\t    //\n\n\t    if (left !== null) {\n\t      leftMatch = _this.match({ direction: 'left', match: left[1], index: _index, branchSymbols: '[]', ignoredSymbols: ignoredSymbols });\n\t    }\n\n\t    // don't match with right side if left already false or no right match necessary\n\t    if (leftMatch.result === false || leftMatch.result === true && right === null) return leftMatch.result ? p[1] : false;\n\n\t    // see left!== null. could be optimized. Creating 3 variations of function\n\t    // so left/right are not checked here, which improves speed, as left/right\n\t    // are in a scope above.\n\t    if (right !== null) {\n\t      rightMatch = _this.match({ direction: 'right', match: right[2], index: _index, branchSymbols: '[]', ignoredSymbols: ignoredSymbols });\n\t    }\n\n\t    // Match! On a match return either the result of given production function\n\t    // or simply return the symbol itself if its no function.\n\t    if (leftMatch.result && rightMatch.result) {\n\t      return typeof p[1] === 'function' ? p[1]({ index: _index, part: _part, currentAxiom: _axiom, params: _params, leftMatchIndices: leftMatch.matchIndices, rightMatchIndices: rightMatch.matchIndices, ignoredSymbols: ignoredSymbols }) : p[1];\n\t    } else {\n\t      return false;\n\t    }\n\t  };\n\n\t  var transformedProduction = [indexSymbol, transformedFunction];\n\n\t  return transformedProduction;\n\t};\n\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n\t  return typeof obj;\n\t} : function (obj) {\n\t  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n\t};\n\n\tvar slicedToArray = function () {\n\t  function sliceIterator(arr, i) {\n\t    var _arr = [];\n\t    var _n = true;\n\t    var _d = false;\n\t    var _e = undefined;\n\n\t    try {\n\t      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n\t        _arr.push(_s.value);\n\n\t        if (i && _arr.length === i) break;\n\t      }\n\t    } catch (err) {\n\t      _d = true;\n\t      _e = err;\n\t    } finally {\n\t      try {\n\t        if (!_n && _i[\"return\"]) _i[\"return\"]();\n\t      } finally {\n\t        if (_d) throw _e;\n\t      }\n\t    }\n\n\t    return _arr;\n\t  }\n\n\t  return function (arr, i) {\n\t    if (Array.isArray(arr)) {\n\t      return arr;\n\t    } else if (Symbol.iterator in Object(arr)) {\n\t      return sliceIterator(arr, i);\n\t    } else {\n\t      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n\t    }\n\t  };\n\t}();\n\n\tfunction LSystem(_ref) {\n\t\tvar axiom = _ref.axiom;\n\t\tvar productions = _ref.productions;\n\t\tvar finals = _ref.finals;\n\t\tvar branchSymbols = _ref.branchSymbols;\n\t\tvar ignoredSymbols = _ref.ignoredSymbols;\n\t\tvar classicParametricSyntax = _ref.classicParametricSyntax;\n\n\t\t// faking default values until better support lands in all browser\n\t\taxiom = typeof axiom !== 'undefined' ? axiom : '';\n\t\tbranchSymbols = typeof branchSymbols !== 'undefined' ? branchSymbols : \"\";\n\t\tignoredSymbols = typeof ignoredSymbols !== 'undefined' ? ignoredSymbols : \"\";\n\t\tclassicParametricSyntax = typeof classicParametricSyntax !== 'undefined' ? classicParametricSyntax : 'false';\n\n\t\t// if using objects in axioms, as used in parametric L-Systems\n\t\tthis.getString = function () {\n\t\t\tvar onlySymbols = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\n\t\t\tif (typeof this.axiom === 'string') return this.axiom;\n\t\t\tif (onlySymbols === true) {\n\t\t\t\treturn this.axiom.reduce(function (prev, current) {\n\t\t\t\t\tif (current.symbol === undefined) {\n\t\t\t\t\t\tconsole.log('found:', current);\n\t\t\t\t\t\tthrow new Error('L-Systems that use only objects as symbols (eg: {symbol: \\'F\\', params: []}), cant use string symbols (eg. \\'F\\')! Check if you always return objects in your productions and no strings.');\n\t\t\t\t\t}\n\t\t\t\t\treturn prev + current.symbol;\n\t\t\t\t}, '');\n\t\t\t} else {\n\t\t\t\treturn JSON.stringify(this.axiom);\n\t\t\t}\n\t\t};\n\n\t\tthis.setAxiom = function (axiom) {\n\t\t\tthis.axiom = axiom;\n\t\t};\n\n\t\tthis.setProduction = function (A, B) {\n\t\t\tvar doAppend = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n\t\t\tvar newProduction = [A, B];\n\t\t\tif (newProduction === undefined) throw new Error('no production specified.');\n\n\t\t\tif (this.parameters.allowClassicSyntax === true) {\n\t\t\t\tnewProduction = transformClassicCSProduction.bind(this)(newProduction, this.ignoredSymbols);\n\t\t\t}\n\t\t\tvar symbol = newProduction[0];\n\n\t\t\tif (doAppend === true && this.productions.has(symbol)) {\n\n\t\t\t\tvar existingProduction = this.productions.get(symbol);\n\t\t\t\t// If existing production results already in an array use this, otherwise\n\t\t\t\t// create new array to append to.\n\t\t\t\tvar productionList = existingProduction[Symbol.iterator] !== undefined && typeof existingProduction !== 'string' && !(existingProduction instanceof String) ? this.productions.get(symbol) : [this.productions.get(symbol)];\n\t\t\t\tproductionList.push(newProduction[1]);\n\t\t\t\tthis.productions.set(symbol, productionList);\n\t\t\t} else {\n\t\t\t\tthis.productions.set(newProduction[0], newProduction[1]);\n\t\t\t}\n\t\t};\n\n\t\t// set multiple productions from name:value Object\n\t\tthis.setProductions = function (newProductions) {\n\t\t\tif (newProductions === undefined) throw new Error('no production specified.');\n\t\t\tthis.clearProductions();\n\n\t\t\t// TODO: once Object.entries() (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) is stable, use that in combo instead of awkward forâ€¦in.\n\t\t\tfor (var condition in newProductions) {\n\t\t\t\tif (newProductions.hasOwnProperty(condition)) {\n\t\t\t\t\tthis.setProduction(condition, newProductions[condition], true);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis.clearProductions = function () {\n\t\t\tthis.productions = new Map();\n\t\t};\n\n\t\tthis.setFinal = function (symbol, final) {\n\t\t\tvar newFinal = [symbol, final];\n\t\t\tif (newFinal === undefined) {\n\t\t\t\tthrow new Error('no final specified.');\n\t\t\t}\n\t\t\tthis.finals.set(newFinal[0], newFinal[1]);\n\t\t};\n\n\t\t// set multiple finals from name:value Object\n\t\tthis.setFinals = function (newFinals) {\n\t\t\tif (newFinals === undefined) throw new Error('no finals specified.');\n\t\t\tthis.finals = new Map();\n\t\t\tfor (var symbol in newFinals) {\n\t\t\t\tif (newFinals.hasOwnProperty(symbol)) {\n\t\t\t\t\tthis.setFinal(symbol, newFinals[symbol]);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis.getProductionResult = function (p, index, part, params) {\n\n\t\t\tvar result = void 0;\n\n\t\t\t// if p is a function, execute function and append return value\n\t\t\tif (typeof p === 'function') {\n\t\t\t\tresult = p({ index: index, currentAxiom: this.axiom, part: part, params: params });\n\n\t\t\t\t/* if p is no function and no iterable, then\n\t   it should be a string (regular) or object\n\t   directly return it then as result */\n\t\t\t} else if (typeof p === 'string' || p instanceof String || (typeof p === 'undefined' ? 'undefined' : _typeof(p)) === 'object' && p[Symbol.iterator] === undefined) {\n\t\t\t\t\tresult = p;\n\n\t\t\t\t\t// if p is a list/iterable\n\t\t\t\t} else if (p[Symbol.iterator] !== undefined && typeof p !== 'string' && !(p instanceof String)) {\n\t\t\t\t\t\t/*\n\t     go through the list and use\n\t     the first valid production in that list. (that returns true)\n\t     This assumes, it's a list of functions.\n\t     */\n\t\t\t\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\t\t\t\tvar _didIteratorError = false;\n\t\t\t\t\t\tvar _iteratorError = undefined;\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfor (var _iterator = p[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\t\t\t\tvar _p = _step.value;\n\n\t\t\t\t\t\t\t\tvar _result = void 0;\n\t\t\t\t\t\t\t\tif (_p[Symbol.iterator] !== undefined && typeof _p !== 'string' && !(_p instanceof String)) {\n\t\t\t\t\t\t\t\t\t// If _p is itself also an Array, recursively get the result.\n\t\t\t\t\t\t\t\t\t_result = this.getProductionResult(_p);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t_result = typeof _p === 'function' ? _p({ index: index, currentAxiom: this.axiom, part: part, params: params }) : _p;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (_result !== undefined && _result !== false) {\n\t\t\t\t\t\t\t\t\tresult = _result;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t_didIteratorError = true;\n\t\t\t\t\t\t\t_iteratorError = err;\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\treturn result === false ? part : result;\n\t\t};\n\n\t\tthis.applyProductions = function () {\n\t\t\t// a axiom can be a string or an array of objects that contain the key/value 'symbol'\n\t\t\tvar newAxiom = typeof this.axiom === 'string' ? '' : [];\n\t\t\tvar index = 0;\n\t\t\t// iterate all symbols/characters of the axiom and lookup according productions\n\t\t\tvar _iteratorNormalCompletion2 = true;\n\t\t\tvar _didIteratorError2 = false;\n\t\t\tvar _iteratorError2 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator2 = this.axiom[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\t\tvar part = _step2.value;\n\n\t\t\t\t\tvar symbol = part;\n\n\t\t\t\t\t// Stuff for classic parametric L-Systems: get actual symbol and possible parameters\n\t\t\t\t\t// params will be given the production function, if applicable.\n\t\t\t\t\tvar params = [];\n\t\t\t\t\tif ((typeof part === 'undefined' ? 'undefined' : _typeof(part)) === 'object' && part.symbol) symbol = part.symbol;\n\t\t\t\t\tif ((typeof part === 'undefined' ? 'undefined' : _typeof(part)) === 'object' && part.params) params = part.params;\n\n\t\t\t\t\tvar result = part;\n\t\t\t\t\tif (this.productions.has(symbol)) {\n\t\t\t\t\t\tvar p = this.productions.get(symbol);\n\t\t\t\t\t\tresult = this.getProductionResult(p, index, part, params);\n\t\t\t\t\t}\n\n\t\t\t\t\t// finally add result to new axiom\n\t\t\t\t\tif (typeof newAxiom === 'string') {\n\t\t\t\t\t\tnewAxiom += result;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If result is an array, merge result into new axiom instead of pushing.\n\t\t\t\t\t\tif (result.constructor === Array) {\n\t\t\t\t\t\t\tArray.prototype.push.apply(newAxiom, result);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewAxiom.push(result);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\n\t\t\t\t// finally set new axiom and also return for convenience\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t_iteratorError2 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t\t_iterator2.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.axiom = newAxiom;\n\t\t\treturn newAxiom;\n\t\t};\n\n\t\t// iterate n times\n\t\tthis.iterate = function () {\n\t\t\tvar n = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n\n\t\t\tthis.iterations = n;\n\t\t\tvar lastIteration = void 0;\n\t\t\tfor (var iteration = 0; iteration < n; iteration++, this.iterationCount++) {\n\t\t\t\tlastIteration = this.applyProductions();\n\t\t\t}\n\t\t\treturn lastIteration;\n\t\t};\n\n\t\tthis.final = function () {\n\t\t\tvar _iteratorNormalCompletion3 = true;\n\t\t\tvar _didIteratorError3 = false;\n\t\t\tvar _iteratorError3 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator3 = this.axiom[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\t\tvar part = _step3.value;\n\n\n\t\t\t\t\t// if we have objects for each symbol, (when using parametric L-Systems)\n\t\t\t\t\t// get actual identifiable symbol character\n\t\t\t\t\tvar symbol = part;\n\t\t\t\t\tif ((typeof part === 'undefined' ? 'undefined' : _typeof(part)) === 'object' && part.symbol) symbol = part.symbol;\n\n\t\t\t\t\tif (this.finals.has(symbol)) {\n\t\t\t\t\t\tvar finalFunction = this.finals.get(symbol);\n\t\t\t\t\t\tvar typeOfFinalFunction = typeof finalFunction === 'undefined' ? 'undefined' : _typeof(finalFunction);\n\t\t\t\t\t\tif (typeOfFinalFunction !== 'function') {\n\t\t\t\t\t\t\tthrow Error('\\'' + symbol + '\\'' + ' has an object for a final function. But it is __not a function__ but a ' + typeOfFinalFunction + '!');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// execute symbols function\n\t\t\t\t\t\tfinalFunction();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// symbol has no final function\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError3 = true;\n\t\t\t\t_iteratorError3 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t\t_iterator3.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/*\n\t \thow to use match():\n\t  \t-----------------------\n\t \tIt is mainly a helper function for context sensitive productions.\n\t \tIf you use the classic syntax, it will by default be automatically transformed to proper\n\t \tJS-Syntax.\n\t \tHowerver, you can use the match helper function in your on productions:\n\t \n\t \tindex is the index of a production using `match`\n\t \teg. in a classic L-System\n\t \n\t \tLSYS = ABCDE\n\t \tB<C>DE -> 'Z'\n\t \n\t \tthe index of the `B<C>D -> 'Z'` production would be the index of C (which is 2) when the\n\t \tproduction would perform match(). so (if not using the ClassicLSystem class) you'd construction your context-sensitive production from C to Z like so:\n\t \n\t \tLSYS.setProduction('C', (index, axiom) => {\n\t \t\t(LSYS.match({index, match: 'B', direction: 'left'}) &&\n\t \t\t LSYS.match({index, match: 'DE', direction: 'right'}) ? 'Z' : 'C')\n\t \t})\n\t \n\t \tYou can just write match({index, ...} instead of match({index: index, ..}) because of new ES6 Object initialization, see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_6\n\t \t*/\n\n\t\tthis.match = function (_ref2) {\n\t\t\tvar axiom_ = _ref2.axiom_;\n\t\t\tvar match = _ref2.match;\n\t\t\tvar ignoredSymbols = _ref2.ignoredSymbols;\n\t\t\tvar branchSymbols = _ref2.branchSymbols;\n\t\t\tvar index = _ref2.index;\n\t\t\tvar direction = _ref2.direction;\n\n\t\t\tvar branchCount = 0;\n\t\t\tvar explicitBranchCount = 0;\n\t\t\taxiom_ = axiom || this.axiom;\n\t\t\tif (branchSymbols === undefined) branchSymbols = this.branchSymbols !== undefined ? this.branchSymbols : [];\n\t\t\tif (ignoredSymbols === undefined) ignoredSymbols = this.ignoredSymbols !== undefined ? this.ignoredSymbols : [];\n\t\t\tvar returnMatchIndices = [];\n\n\t\t\tvar branchStart = void 0,\n\t\t\t    branchEnd = void 0,\n\t\t\t    axiomIndex = void 0,\n\t\t\t    loopIndexChange = void 0,\n\t\t\t    matchIndex = void 0,\n\t\t\t    matchIndexChange = void 0,\n\t\t\t    matchIndexOverflow = void 0;\n\t\t\t// set some variables depending on the direction to match\n\t\t\tif (direction === 'right') {\n\t\t\t\tloopIndexChange = matchIndexChange = +1;\n\t\t\t\taxiomIndex = index + 1;\n\t\t\t\tmatchIndex = 0;\n\t\t\t\tmatchIndexOverflow = match.length;\n\t\t\t\tif (branchSymbols.length > 0) {\n\t\t\t\t\t;\n\t\t\t\t\tvar _branchSymbols = branchSymbols;\n\n\t\t\t\t\tvar _branchSymbols2 = slicedToArray(_branchSymbols, 2);\n\n\t\t\t\t\tbranchStart = _branchSymbols2[0];\n\t\t\t\t\tbranchEnd = _branchSymbols2[1];\n\t\t\t\t}\n\t\t\t} else if (direction === 'left') {\n\t\t\t\tloopIndexChange = matchIndexChange = -1;\n\t\t\t\taxiomIndex = index - 1;\n\t\t\t\tmatchIndex = match.length - 1;\n\t\t\t\tmatchIndexOverflow = -1;\n\t\t\t\tif (branchSymbols.length > 0) {\n\t\t\t\t\t;\n\t\t\t\t\tvar _branchSymbols3 = branchSymbols;\n\n\t\t\t\t\tvar _branchSymbols4 = slicedToArray(_branchSymbols3, 2);\n\n\t\t\t\t\tbranchEnd = _branchSymbols4[0];\n\t\t\t\t\tbranchStart = _branchSymbols4[1];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow Error(direction, 'is not a valid direction for matching.');\n\t\t\t}\n\n\t\t\tfor (; axiomIndex < axiom_.length && axiomIndex >= 0; axiomIndex += loopIndexChange) {\n\t\t\t\t// FIXME: what about objects with .symbol\n\n\t\t\t\tvar axiomSymbol = axiom_[axiomIndex];\n\t\t\t\t// For objects match for objects `symbol`\n\t\t\t\tif ((typeof axiomSymbol === 'undefined' ? 'undefined' : _typeof(axiomSymbol)) === 'object') axiomSymbol = axiomSymbol.symbol;\n\t\t\t\tvar matchSymbol = match[matchIndex];\n\n\t\t\t\t// compare current symbol of axiom with current symbol of match\n\t\t\t\tif (axiomSymbol === matchSymbol) {\n\n\t\t\t\t\tif (branchCount === 0 || explicitBranchCount > 0) {\n\t\t\t\t\t\t// if its a match and previously NOT inside branch (branchCount===0) or in explicitly wanted branch (explicitBranchCount > 0)\n\n\t\t\t\t\t\t// if a bracket was explicitly stated in match axiom\n\t\t\t\t\t\tif (axiomSymbol === branchStart) {\n\t\t\t\t\t\t\texplicitBranchCount++;\n\t\t\t\t\t\t\tbranchCount++;\n\t\t\t\t\t\t\tmatchIndex += matchIndexChange;\n\t\t\t\t\t\t} else if (axiomSymbol === branchEnd) {\n\t\t\t\t\t\t\texplicitBranchCount = Math.max(0, explicitBranchCount - 1);\n\t\t\t\t\t\t\tbranchCount = Math.max(0, branchCount - 1);\n\t\t\t\t\t\t\t// only increase match if we are out of explicit branch\n\n\t\t\t\t\t\t\tif (explicitBranchCount === 0) {\n\n\t\t\t\t\t\t\t\tmatchIndex += matchIndexChange;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturnMatchIndices.push(axiomIndex);\n\t\t\t\t\t\t\tmatchIndex += matchIndexChange;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// overflowing matchIndices (matchIndex + 1 for right match, matchIndexEnd for left match )?\n\t\t\t\t\t// -> no more matches to do. return with true, as everything matched until here\n\t\t\t\t\t// *yay*\n\t\t\t\t\tif (matchIndex === matchIndexOverflow) {\n\t\t\t\t\t\treturn { result: true, matchIndices: returnMatchIndices };\n\t\t\t\t\t}\n\t\t\t\t} else if (axiomSymbol === branchStart) {\n\t\t\t\t\tbranchCount++;\n\t\t\t\t\tif (explicitBranchCount > 0) explicitBranchCount++;\n\t\t\t\t} else if (axiomSymbol === branchEnd) {\n\t\t\t\t\tbranchCount = Math.max(0, branchCount - 1);\n\t\t\t\t\tif (explicitBranchCount > 0) explicitBranchCount = Math.max(0, explicitBranchCount - 1);\n\t\t\t\t} else if ((branchCount === 0 || explicitBranchCount > 0 && matchSymbol !== branchEnd) && ignoredSymbols.includes(axiomSymbol) === false) {\n\t\t\t\t\t// not in branchSymbols/branch? or if in explicit branch, and not at the very end of\n\t\t\t\t\t// condition (at the ]), and symbol not in ignoredSymbols ? then false\n\t\t\t\t\treturn { result: false, matchIndices: returnMatchIndices };\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn { result: false, matchIndices: returnMatchIndices };\n\t\t};\n\n\t\t// finally init stuff\n\t\tthis.parameters = {\n\t\t\tallowClassicSyntax: true\n\t\t};\n\n\t\tthis.ignoredSymbols = ignoredSymbols;\n\t\tthis.setAxiom(axiom);\n\t\tthis.productions = new Map();\n\n\t\tthis.branchSymbols = branchSymbols;\n\n\t\tthis.classicParametricSyntax = classicParametricSyntax;\n\n\t\tif (productions) this.setProductions(productions);\n\t\tif (finals) this.setFinals(finals);\n\n\t\tthis.iterationCount = 0;\n\t\treturn this;\n\t}\n\n\t// Set classic syntax helpers to library scope to be used outside of library context\n\t// for users eg.\n\tLSystem.transformClassicStochasticProductions = transformClassicStochasticProductions;\n\tLSystem.transformClassicCSProduction = transformClassicCSProduction;\n\tLSystem.transformClassicParametricAxiom = transformClassicParametricAxiom;\n\tLSystem.testClassicParametricSyntax = testClassicParametricSyntax;\n\n\tmodule.exports = LSystem;\n\n/***/ }\n/******/ ]);",e.p+"b1804293b737ae505bcd.worker.js")}},function(t,n){var e=window.URL||window.webkitURL;t.exports=function(t,n){try{try{var r;try{var i=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder;(r=new i).append(t),r=r.getBlob()}catch(n){r=new Blob([t])}return new Worker(e.createObjectURL(r))}catch(n){return new Worker("data:application/javascript,"+encodeURIComponent(t))}}catch(t){return new Worker(n)}}},function(t,n){"use strict";function e(t){return function(){for(var n=t,e=n.length,r=Math.random(),i=0;i<e;i++)if(r<=(i+1)/e)return n[i];console.error("Should have returned a result of the list, something is wrong here with the random numbers?.")}}function r(t){return/\(.+\)/.test(t)}function i(t){for(var n=t.replace(/\s+/g,"").split(/[\(\)]/),e=[],r=0;r<n.length-1;r+=2){var i=n[r+1].split(",").map(Number);e.push({symbol:n[r],params:i})}}function o(t,n){var e=this,r=t[0].match(/(.+)<(.)/),i=t[0].match(/(.)>(.+)/);if(null===r&&null===i)return t;var o=null!==r?r[2]:i[1];if(null!==r&&null!==i&&r[2]!==i[1])throw new Error("index symbol differs in context sensitive production from left to right check.",r[2],"!==",i[1]);return[o,function(o){var a=o.index,s=o.part,l=o.currentAxiom,c=o.params,u={result:!0},m={result:!0};return null!==r&&(u=e.match({direction:"left",match:r[1],index:a,branchSymbols:"[]",ignoredSymbols:n})),!1===u.result||!0===u.result&&null===i?!!u.result&&t[1]:(null!==i&&(m=e.match({direction:"right",match:i[2],index:a,branchSymbols:"[]",ignoredSymbols:n})),!(!u.result||!m.result)&&("function"==typeof t[1]?t[1]({index:a,part:s,currentAxiom:l,params:c,leftMatchIndices:u.matchIndices,rightMatchIndices:m.matchIndices,ignoredSymbols:n}):t[1]))}]}function a(t){var n=t.axiom,e=t.productions,r=t.finals,i=t.branchSymbols,a=t.ignoredSymbols,c=t.classicParametricSyntax;return n=void 0!==n?n:"",i=void 0!==i?i:"",a=void 0!==a?a:"",c=void 0!==c?c:"false",this.getString=function(){var t=arguments.length<=0||void 0===arguments[0]||arguments[0];return"string"==typeof this.axiom?this.axiom:!0===t?this.axiom.reduce(function(t,n){if(void 0===n.symbol)throw console.log("found:",n),new Error("L-Systems that use only objects as symbols (eg: {symbol: 'F', params: []}), cant use string symbols (eg. 'F')! Check if you always return objects in your productions and no strings.");return t+n.symbol},""):JSON.stringify(this.axiom)},this.setAxiom=function(t){this.axiom=t},this.setProduction=function(t,n){var e=!(arguments.length<=2||void 0===arguments[2])&&arguments[2],r=[t,n];if(void 0===r)throw new Error("no production specified.");!0===this.parameters.allowClassicSyntax&&(r=o.bind(this)(r,this.ignoredSymbols));var i=r[0];if(!0===e&&this.productions.has(i)){var a=this.productions.get(i),s=void 0===a[Symbol.iterator]||"string"==typeof a||a instanceof String?[this.productions.get(i)]:this.productions.get(i);s.push(r[1]),this.productions.set(i,s)}else this.productions.set(r[0],r[1])},this.setProductions=function(t){if(void 0===t)throw new Error("no production specified.");this.clearProductions();for(var n in t)t.hasOwnProperty(n)&&this.setProduction(n,t[n],!0)},this.clearProductions=function(){this.productions=new Map},this.setFinal=function(t,n){var e=[t,n];if(void 0===e)throw new Error("no final specified.");this.finals.set(e[0],e[1])},this.setFinals=function(t){if(void 0===t)throw new Error("no finals specified.");this.finals=new Map;for(var n in t)t.hasOwnProperty(n)&&this.setFinal(n,t[n])},this.getProductionResult=function(t,n,e,r){var i=void 0;if("function"==typeof t)i=t({index:n,currentAxiom:this.axiom,part:e,params:r});else if("string"==typeof t||t instanceof String||"object"===(void 0===t?"undefined":s(t))&&void 0===t[Symbol.iterator])i=t;else if(void 0!==t[Symbol.iterator]&&"string"!=typeof t&&!(t instanceof String)){var o=!0,a=!1,l=void 0;try{for(var c,u=t[Symbol.iterator]();!(o=(c=u.next()).done);o=!0){var m=c.value,d=void 0;if(void 0!==(d=void 0===m[Symbol.iterator]||"string"==typeof m||m instanceof String?"function"==typeof m?m({index:n,currentAxiom:this.axiom,part:e,params:r}):m:this.getProductionResult(m))&&!1!==d){i=d;break}}}catch(t){a=!0,l=t}finally{try{!o&&u.return&&u.return()}finally{if(a)throw l}}}return!1===i?e:i},this.applyProductions=function(){var t="string"==typeof this.axiom?"":[],n=0,e=!0,r=!1,i=void 0;try{for(var o,a=this.axiom[Symbol.iterator]();!(e=(o=a.next()).done);e=!0){var l=o.value,c=l,u=[];"object"===(void 0===l?"undefined":s(l))&&l.symbol&&(c=l.symbol),"object"===(void 0===l?"undefined":s(l))&&l.params&&(u=l.params);var m=l;if(this.productions.has(c)){var d=this.productions.get(c);m=this.getProductionResult(d,n,l,u)}"string"==typeof t?t+=m:m.constructor===Array?Array.prototype.push.apply(t,m):t.push(m),n++}}catch(t){r=!0,i=t}finally{try{!e&&a.return&&a.return()}finally{if(r)throw i}}return this.axiom=t,t},this.iterate=function(){var t=arguments.length<=0||void 0===arguments[0]?1:arguments[0];this.iterations=t;for(var n=void 0,e=0;e<t;e++,this.iterationCount++)n=this.applyProductions();return n},this.final=function(){var t=!0,n=!1,e=void 0;try{for(var r,i=this.axiom[Symbol.iterator]();!(t=(r=i.next()).done);t=!0){var o=r.value,a=o;if("object"===(void 0===o?"undefined":s(o))&&o.symbol&&(a=o.symbol),this.finals.has(a)){var l=this.finals.get(a),c=void 0===l?"undefined":s(l);if("function"!==c)throw Error("'"+a+"' has an object for a final function. But it is __not a function__ but a "+c+"!");l()}}}catch(t){n=!0,e=t}finally{try{!t&&i.return&&i.return()}finally{if(n)throw e}}},this.match=function(t){var e=t.axiom_,r=t.match,i=t.ignoredSymbols,o=t.branchSymbols,a=t.index,c=t.direction,u=0,m=0;e=n||this.axiom,void 0===o&&(o=void 0!==this.branchSymbols?this.branchSymbols:[]),void 0===i&&(i=void 0!==this.ignoredSymbols?this.ignoredSymbols:[]);var d=[],h=void 0,f=void 0,p=void 0,y=void 0,b=void 0,g=void 0,x=void 0;if("right"===c){if(y=g=1,p=a+1,b=0,x=r.length,o.length>0){var v=l(o,2);h=v[0],f=v[1]}}else{if("left"!==c)throw Error(c,"is not a valid direction for matching.");if(y=g=-1,p=a-1,b=r.length-1,x=-1,o.length>0){var S=l(o,2);f=S[0],h=S[1]}}for(;p<e.length&&p>=0;p+=y){var w=e[p];"object"===(void 0===w?"undefined":s(w))&&(w=w.symbol);var _=r[b];if(w===_){if((0===u||m>0)&&(w===h?(m++,u++,b+=g):w===f?(m=Math.max(0,m-1),u=Math.max(0,u-1),0===m&&(b+=g)):(d.push(p),b+=g)),b===x)return{result:!0,matchIndices:d}}else if(w===h)u++,m>0&&m++;else if(w===f)u=Math.max(0,u-1),m>0&&(m=Math.max(0,m-1));else if((0===u||m>0&&_!==f)&&!1===i.includes(w))return{result:!1,matchIndices:d}}return{result:!1,matchIndices:d}},this.parameters={allowClassicSyntax:!0},this.ignoredSymbols=a,this.setAxiom(n),this.productions=new Map,this.branchSymbols=i,this.classicParametricSyntax=c,e&&this.setProductions(e),r&&this.setFinals(r),this.iterationCount=0,this}var s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol?"symbol":typeof t},l=function(){function t(t,n){var e=[],r=!0,i=!1,o=void 0;try{for(var a,s=t[Symbol.iterator]();!(r=(a=s.next()).done)&&(e.push(a.value),!n||e.length!==n);r=!0);}catch(t){i=!0,o=t}finally{try{!r&&s.return&&s.return()}finally{if(i)throw o}}return e}return function(n,e){if(Array.isArray(n))return n;if(Symbol.iterator in Object(n))return t(n,e);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}();a.transformClassicStochasticProductions=e,a.transformClassicCSProduction=o,a.transformClassicParametricAxiom=i,a.testClassicParametricSyntax=r,t.exports=a},function(t,n){"use strict";AFRAME.registerPrimitive("a-lsystem",{defaultComponents:{lsystem:{axiom:"F",productions:"F:F++F++F++F",iterations:3,angle:60}},mappings:{axiom:"lsystem.axiom",productions:"lsystem.productions",segmentMixins:"lsystem.segmentMixins",iterations:"lsystem.iterations",angle:"lsystem.angle"}})}]);
